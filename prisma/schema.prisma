generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String   @id @default(cuid())
  crmCustomerId String   @unique
  voornaam      String
  tussenvoegsel String?
  achternaam    String
  email         String
  mobiel        String?
  role          Role
  createdAt     DateTime @default(now())

  // Cohort membership (student/teacher/admin)
  enrollments Enrollment[]

  // Student assessments (as student)
  assessments Assessment[] @relation("StudentAssessments")

  // Teacher per-question corrections
  teacherScores TeacherScore[]

  // Teacher publish gate per assessment
  teacherReviews TeacherReview[]
}

model Cohort {
  id           String   @id @default(cuid())
  uitvoeringId String   @unique
  naam         String
  traject      String?
  createdAt    DateTime @default(now())

  enrollments Enrollment[]
}

model Enrollment {
  id               String   @id @default(cuid())
  userId           String
  cohortId         String
  coachNaam        String?
  trajectStatus    String?
  assessmentLocked Boolean  @default(false)
  createdAt        DateTime @default(now())

  user   User   @relation(fields: [userId], references: [id])
  cohort Cohort @relation(fields: [cohortId], references: [id])

  @@unique([userId, cohortId], name: "userId_cohortId")
}

/**
 * =========================
 * Assessments & scores
 * =========================
 */

model Assessment {
  id String @id @default(cuid())

  // Student waarvoor dit assessment is
  studentId String
  student   User   @relation("StudentAssessments", fields: [studentId], references: [id])

  // Context zoals je UI gebruikt
  rubricKey String // bijv "1vo"
  moment    Moment // "M1" | "M2" | "M3"

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Student ingevulde scores (raw)
  scores Score[]

  // Docentcorrecties + feedback
  teacherScores  TeacherScore[]
  teacherReviews TeacherReview[]

  // 1 assessment per student per rubricKey per moment
  @@unique([studentId, rubricKey, moment], name: "student_rubric_moment")
}

model Score {
  id           String     @id @default(cuid())
  assessmentId String
  assessment   Assessment @relation(fields: [assessmentId], references: [id])

  // Per vraag
  themeId    String
  questionId String

  // Student score
  score   Int
  comment String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // 1 row per assessment per vraag
  @@unique([assessmentId, themeId, questionId], name: "assessment_theme_question")
}

/**
 * =========================
 * Teacher layer (multi-docent)
 * =========================
 */

model TeacherScore {
  id String @id @default(cuid())

  assessmentId String
  assessment   Assessment @relation(fields: [assessmentId], references: [id])

  teacherId String
  teacher   User   @relation(fields: [teacherId], references: [id])

  themeId    String
  questionId String

  correctedScore Int?
  feedback       String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // 1 docent-correctie per assessment per vraag
  @@unique([assessmentId, teacherId, themeId, questionId], name: "assessment_teacher_theme_question")
}

model TeacherReview {
  id String @id @default(cuid())

  assessmentId String
  assessment   Assessment @relation(fields: [assessmentId], references: [id])

  teacherId String
  teacher   User   @relation(fields: [teacherId], references: [id])

  correctedScore Int?
  feedback       String?
  status         ReviewStatus @default(DRAFT)
  publishedAt    DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // 1 review per docent per assessment
  @@unique([assessmentId, teacherId], name: "assessment_teacher")
}

enum Role {
  STUDENT
  TEACHER
  ADMIN
}

enum Moment {
  M1
  M2
  M3
}

enum ReviewStatus {
  DRAFT
  PUBLISHED
}
